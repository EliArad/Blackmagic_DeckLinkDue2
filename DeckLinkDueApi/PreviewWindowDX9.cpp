/* -LICENSE-START-
** Copyright (c) 2019 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
** 
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/


#include "stdafx.h"
#include <comutil.h>
#include "D3D9Types.h"
#include "PreviewWindowDX9.h"
#include "Bgra32VideoFrame.h"


PreviewWindowDX9::PreviewWindowDX9()
	: m_refCount(1)
	
{
	m_init = false;

	receivedVideoFrame = NULL;
	deckLinkFrameConverter = NULL;
	bgra32Frame = NULL;
	m_previewVideo = true;
	m_useSourceFilter = false;

	m_rgb = true;
	pixels180Degree = new unsigned char[1920* 1080 * 4];

}

bool PreviewWindowDX9::init()
{

	// Create the DeckLink screen preview helper
	if (m_deckLinkScreenPreviewHelper.CoCreateInstance(CLSID_CDeckLinkDX9ScreenPreviewHelper, nullptr, CLSCTX_ALL) != S_OK)
		return false;


	// Create frame conversion instance
	HRESULT result = GetDeckLinkVideoConversion(&deckLinkFrameConverter);
	if (result != S_OK)
		return false;
	
	return true;
}


HRESULT PreviewWindowDX9::GetDeckLinkVideoConversion(IDeckLinkVideoConversion **deckLinkVideoConversion)
{
	HRESULT result = S_OK;

	result = CoCreateInstance(CLSID_CDeckLinkVideoConversion, NULL, CLSCTX_ALL, IID_IDeckLinkVideoConversion, (void**)deckLinkVideoConversion);
	if (FAILED(result))
	{
		fprintf(stderr, "A DeckLink video conversion interface could not be created.\n");
	}

	return result;
}

void PreviewWindowDX9::SetFrameCallback(FrameCallback p)
{
	pFrameCallback = p;
}

bool PreviewWindowDX9::SetVideoHandle(HWND p)
{
	 
	// Initialise DirectX
	return initDirectX(p);

}

bool PreviewWindowDX9::initDirectX(HWND hWnd)
{
	D3DPRESENT_PARAMETERS	d3dpp;
	bool					result = false;

	if (m_init == true)
		return true;


	m_dx3D = Direct3DCreate9(D3D_SDK_VERSION);
	if (m_dx3D == nullptr)
		goto bail;

	ZeroMemory(&d3dpp, sizeof(D3DPRESENT_PARAMETERS));
	d3dpp.BackBufferFormat = D3DFMT_UNKNOWN;
	d3dpp.BackBufferCount = 2;
	d3dpp.Windowed = TRUE;
	d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;
	d3dpp.hDeviceWindow = hWnd;
	d3dpp.PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;

	if (m_dx3D->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hWnd, D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_MULTITHREADED, &d3dpp, &m_dx3DDevice) != D3D_OK)
		goto bail;

	if (m_deckLinkScreenPreviewHelper->Initialize(m_dx3DDevice) == S_OK)
		result = true;

	m_init = result;

bail:
	return result;
}

void PreviewWindowDX9::Render()
{
	D3DVIEWPORT9	viewport;
	RECT			rect;

	m_dx3DDevice->BeginScene();

	m_dx3DDevice->GetViewport(&viewport);

	rect.top = viewport.Y;
	rect.left = viewport.X;
	rect.bottom = viewport.Y + viewport.Height;
	rect.right = viewport.X + viewport.Width;

	m_deckLinkScreenPreviewHelper->Render(&rect);
	
	m_dx3DDevice->EndScene();
	m_dx3DDevice->Present(nullptr, nullptr, nullptr, nullptr);
}


HRESULT PreviewWindowDX9::QueryInterface(REFIID iid, LPVOID *ppv)
{
	*ppv = nullptr;
	return E_NOINTERFACE;
}

ULONG PreviewWindowDX9::AddRef()
{
	return ++m_refCount;
}

ULONG PreviewWindowDX9::Release()
{
	ULONG newRefValue = --m_refCount;
	if (newRefValue == 0)
		delete this;

	return newRefValue;
}

void PreviewWindowDX9::SetSourceFilter(CComPtr<ILiveSource> p)
{	
	pFrameLiveSourceInterface = p;
	m_useSourceFilter = true;
}

void PreviewWindowDX9::SetPreviewVideo(bool preview)
{
	m_previewVideo = preview;
}

HRESULT	PreviewWindowDX9::DrawFrame(IDeckLinkVideoFrame* theFrame)
{
	if (!theFrame)
		return E_INVALIDARG;

	// Set current frame in preview helper
	HRESULT hr = m_deckLinkScreenPreviewHelper->SetFrame(theFrame);

	
	int width = theFrame->GetWidth();
	int height = theFrame->GetHeight();

	if (width != 1920)
		return S_OK;

	BMDPixelFormat pif;
	void* videoPixels;

	if (pFrameCallback != nullptr || m_useSourceFilter == true)
	{

		pif = theFrame->GetPixelFormat();

		if (bgra32Frame == NULL)
			bgra32Frame = new Bgra32VideoFrame(width, height, theFrame->GetFlags());

		if (m_rgb == true)
		{
			deckLinkFrameConverter->ConvertFrame(theFrame, bgra32Frame);
			bgra32Frame->GetBytes(&videoPixels);
		}
		else
		{
			theFrame->GetBytes(&videoPixels);
		}
	}

	if (m_useSourceFilter == true)
	{
		bool swap_180 = false;
		if (swap_180 == true)
		{
			uint8_t *p = (uint8_t *)videoPixels;
			 

			pFrameLiveSourceInterface->AddFrame((BYTE *)pixels180Degree, RGBA_HD_SIZE);
		}
		else 
		{
			pFrameLiveSourceInterface->AddFrame((BYTE *)videoPixels, RGBA_HD_SIZE);
		}
	}

	if (pFrameCallback != nullptr)
	{ 
		pFrameCallback((uint8_t *)videoPixels, width, height, pif);
	}

	if (m_previewVideo == true)
		Render();

	return S_OK;
}

