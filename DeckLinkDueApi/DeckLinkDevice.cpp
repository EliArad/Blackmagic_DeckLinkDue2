/* -LICENSE-START-
** Copyright (c) 2020 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
** 
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/

#include "stdafx.h"
#include <stdint.h>
#include <comutil.h>
#include "DeckLinkDevice.h"

DeckLinkDevice::DeckLinkDevice(CComPtr<IDeckLink>& device) : 
	m_refCount(1), 
	m_deckLink(device), 
	m_deckLinkInput(device), 
	m_deckLinkConfig(device),	
	m_deckLinkHDMIInputEDID(device), 
	m_supportsFormatDetection(false),
	m_currentlyCapturing(false),
	m_applyDetectedInputMode(false)
{
	if (!m_deckLinkInput)
		throw std::runtime_error("DeckLink device does not have an input interface.");
}

HRESULT	DeckLinkDevice::QueryInterface(REFIID iid, LPVOID *ppv)
{
	HRESULT result = E_NOINTERFACE;

	if (ppv == NULL)
		return E_INVALIDARG;

	// Initialise the return result
	*ppv = NULL;

	// Obtain the IUnknown interface and compare it the provided REFIID
	if (iid == IID_IUnknown)
	{
		*ppv = this;
		AddRef();
		result = S_OK;
	}
	else if (iid == IID_IDeckLinkInputCallback)
	{
		*ppv = static_cast<IDeckLinkInputCallback*>(this);
		AddRef();
		result = S_OK;
	}

	return result;
}

ULONG DeckLinkDevice::AddRef(void)
{
	return ++m_refCount;
}

ULONG DeckLinkDevice::Release(void)
{
	ULONG newRefValue = --m_refCount;
	if (newRefValue == 0)
		delete this;

	return newRefValue;
}

bool DeckLinkDevice::init()
{
	CComBSTR								deviceNameBSTR;
	CComQIPtr<IDeckLinkProfileAttributes>	deckLinkAttributes(m_deckLink);

	if (!deckLinkAttributes)
		return false;

	// Check if input mode detection is supported by the device.
	if (deckLinkAttributes->GetFlag(BMDDeckLinkSupportsInputFormatDetection, &m_supportsFormatDetection) != S_OK)
		m_supportsFormatDetection = false;

	// Enable all EDID functionality if possible
	if (m_deckLinkHDMIInputEDID)
	{
		int64_t allKnownRanges = bmdDynamicRangeSDR | bmdDynamicRangeHDRStaticPQ | bmdDynamicRangeHDRStaticHLG;
		m_deckLinkHDMIInputEDID->SetInt(bmdDeckLinkHDMIInputEDIDDynamicRange, allKnownRanges);
		m_deckLinkHDMIInputEDID->WriteToEDID();
	}

	// Get device name
	if (m_deckLink->GetDisplayName(&deviceNameBSTR) == S_OK)
	{
		m_deviceName = CString(deviceNameBSTR);
		::SysFreeString(deviceNameBSTR);
	}
	else
	{
		m_deviceName = _T("DeckLink");
	}

	return true;
}

bool DeckLinkDevice::startCapture(BMDDisplayMode displayMode, IDeckLinkScreenPreviewCallback* screenPreviewCallback, bool applyDetectedInputMode)
{
	BMDVideoInputFlags		videoInputFlags = bmdVideoInputFlagDefault;

	m_applyDetectedInputMode = applyDetectedInputMode;

	// Enable input video mode detection if the device supports it
	if (m_supportsFormatDetection)
		videoInputFlags |= bmdVideoInputEnableFormatDetection;

	// Set the screen preview
	m_deckLinkInput->SetScreenPreviewCallback(screenPreviewCallback);

	// Set capture callback
	m_deckLinkInput->SetCallback(this);

	m_pixelFormat = bmdFormat8BitYUV;
	// Set the video input mode
	if (m_deckLinkInput->EnableVideoInput(displayMode, 										   
										  m_pixelFormat,
									      videoInputFlags) != S_OK)
	{
		if (m_errorListener)
			m_errorListener(DeviceError::EnableVideoInputFailed);

		return false;
	}

	// Start the capture
	if (m_deckLinkInput->StartStreams() != S_OK)
	{
		if (m_errorListener)
			m_errorListener(DeviceError::StartStreamsFailed);

		return false;
	}

	m_currentlyCapturing = true;

	return true;
}

void DeckLinkDevice::stopCapture()
{
	if (m_deckLinkInput)
	{
		// Stop the capture
		m_deckLinkInput->StopStreams();

		// Unregister screen preview callback
		m_deckLinkInput->SetScreenPreviewCallback(nullptr);

		// Delete capture callback
		m_deckLinkInput->SetCallback(nullptr);

		// Disable video input
		m_deckLinkInput->DisableVideoInput();
	}

	m_currentlyCapturing = false;
}

void DeckLinkDevice::queryDisplayModes(QueryDisplayModeFunc func)
{
	CComPtr<IDeckLinkDisplayModeIterator>	displayModeIterator;
	CComPtr<IDeckLinkDisplayMode>			displayMode;

	if (!func)
		return;

	if (m_deckLinkInput->GetDisplayModeIterator(&displayModeIterator) != S_OK)
		return;

	while (displayModeIterator->Next(&displayMode) == S_OK)
	{
		func(displayMode);
		displayMode.Release();
	}
}


HRESULT DeckLinkDevice::VideoInputFormatChanged2(BMDVideoInputFormatChangedEvents notificationEvents, IDeckLinkDisplayMode *newMode, BMDDetectedVideoInputFormatFlags detectedSignalFlags)
{
	BMDPixelFormat	pixelFormat = m_pixelFormat;

	// Restart capture with the new video mode if told to
	if (!m_applyDetectedInputMode)
		goto bail;

	// Restart capture with the new video mode if told to
	if (notificationEvents & bmdVideoInputColorspaceChanged)
	{
		if (detectedSignalFlags & bmdDetectedVideoInputRGB444)
			pixelFormat = bmdFormat8BitBGRA;
		else if (detectedSignalFlags & bmdDetectedVideoInputYCbCr422)
			pixelFormat = bmdFormat8BitYUV;
		else
			goto bail;
	}

	// Restart streams if either dispay mode or colorspace has changed
	if ((notificationEvents & bmdVideoInputDisplayModeChanged) || (pixelFormat != m_pixelFormat))
	{
		// Stop and flush the capture
		m_deckLinkInput->StopStreams();
		m_deckLinkInput->FlushStreams();

		// Set the video input mode
		if (m_deckLinkInput->EnableVideoInput(newMode->GetDisplayMode(), pixelFormat, bmdVideoInputEnableFormatDetection) != S_OK)
		{
			 
			goto bail;
		}

		// Start the capture
		if (m_deckLinkInput->StartStreams() != S_OK)
		{
			 
			goto bail;
		}

		m_pixelFormat = pixelFormat;
	}

	// Send event with detected display mode
	if (notificationEvents & (bmdVideoInputDisplayModeChanged | bmdVideoInputFieldDominanceChanged))
		if (m_videoFormatChangedCallback != nullptr)
			m_videoFormatChangedCallback(newMode->GetDisplayMode());

bail:
	return S_OK;
}

HRESULT DeckLinkDevice::VideoInputFormatChanged(BMDVideoInputFormatChangedEvents notificationEvents, IDeckLinkDisplayMode *newMode, BMDDetectedVideoInputFormatFlags detectedSignalFlags)
{	
	BMDPixelFormat pixelFormat;

 
	return VideoInputFormatChanged2(notificationEvents, newMode, detectedSignalFlags);


	// Restart capture with the new video mode if told to
	if (!m_applyDetectedInputMode)
		return S_OK;

	if (detectedSignalFlags & bmdDetectedVideoInputRGB444)
	{
		if (detectedSignalFlags & bmdDetectedVideoInput8BitDepth)
			pixelFormat = bmdFormat8BitARGB;
		else if (detectedSignalFlags & bmdDetectedVideoInput10BitDepth)
			pixelFormat = bmdFormat10BitRGB;
		else if (detectedSignalFlags & bmdDetectedVideoInput12BitDepth)
			pixelFormat = bmdFormat12BitRGB;
		else
			// Invalid color depth for RGB
			return E_INVALIDARG;
	}
	else if (detectedSignalFlags & bmdDetectedVideoInputYCbCr422)
	{
		if (detectedSignalFlags & bmdDetectedVideoInput8BitDepth)
			pixelFormat = bmdFormat8BitYUV;
		else if (detectedSignalFlags & bmdDetectedVideoInput10BitDepth)
			pixelFormat = bmdFormat10BitYUV;
		else
			// Invalid color depth for YUV
			return E_INVALIDARG;
	}
	else
		// Unexpected detected video input format flags
		return E_INVALIDARG;

	if ((notificationEvents & bmdVideoInputDisplayModeChanged) ||
		(notificationEvents & bmdVideoInputColorspaceChanged))
	{
		// Stop the capture
		m_deckLinkInput->StopStreams();

		// Set the video input mode
		if (m_deckLinkInput->EnableVideoInput(newMode->GetDisplayMode(), pixelFormat, bmdVideoInputEnableFormatDetection) != S_OK)
		{
			// Let the UI know we couldnt restart the capture with the detected input mode
			if (m_errorListener)
				m_errorListener(DeviceError::ReenableVideoInputFailed);

			return E_FAIL;
		}

		// Start the capture
		if (m_deckLinkInput->StartStreams() != S_OK)
		{
			// Let the UI know we couldnt restart the capture with the detected input mode
			if (m_errorListener)
				m_errorListener(DeviceError::ReenableVideoInputFailed);

			return E_FAIL;
		}

		// Update the UI with detected display mode
		if (m_videoFormatChangedCallback)
			m_videoFormatChangedCallback(newMode->GetDisplayMode());
	}

	return S_OK;
}

HRESULT DeckLinkDevice::VideoInputFrameArrived(IDeckLinkVideoInputFrame* videoFrame, IDeckLinkAudioInputPacket* audioPacket)
{
	if ((videoFrame != nullptr) &&  (m_videoFrameArrivedCallback != nullptr))
	{
		CComPtr<IDeckLinkVideoInputFrame> inputFrame = videoFrame;
		m_videoFrameArrivedCallback(inputFrame);
	}

	return S_OK;
}

